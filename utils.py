import os
import random

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import seaborn as sns
import torch
from sklearn.metrics import confusion_matrix
from tqdm import tqdm


def set_seed(seed):
    random.seed(seed)
    os.environ["PYTHONHASHSEED"] = str(seed)
    np.random.seed(seed)
    torch.manual_seed(seed)
    if torch.cuda.is_available():
        torch.backends.cudnn.deterministic = True
        torch.backends.cudnn.benchmark = True


def count_parameters(model, trainable_only=True):
    if trainable_only:
        return sum(p.numel() for p in model.parameters() if p.requires_grad)
    return sum(p.numel() for p in model.parameters())


def set_plt_style():
    plt.rcParams.update(
        {"text.usetex": True, "font.family": "serif", "font.serif": ["cm"],}
    )


def plot_confusion_matrix(model, test_loader, save_title, device, normalize="all"):
    y_true, y_pred = predict(model, test_loader, device)
    conf_mat = confusion_matrix(y_true, y_pred, normalize=normalize)
    axis_labels = ("Benign", "Malware")
    df = pd.DataFrame(conf_mat, index=axis_labels, columns=axis_labels)
    plot = sns.heatmap(df, annot=True, cmap="Blues")
    plot.figure.savefig(os.path.join("figs", f"{save_title}.png"), dpi=300)


@torch.no_grad()
def predict(model, data_loader, device, to_numpy=True):
    model.eval()
    y_true = []
    y_pred = []
    for inputs, labels in data_loader:
        inputs = inputs.to(device)
        outputs = model(inputs)
        outputs = outputs > 0
        y_true.append(labels)
        y_pred.append(outputs)
    y_true = torch.cat(y_true).to(int).to(device)
    y_pred = torch.cat(y_pred).to(int).to(device)
    if to_numpy:
        y_true = y_true.numpy()
        y_pred = y_pred.numpy()
    assert y_true.shape == y_pred.shape
    model.train()
    return y_true, y_pred


def plot_train_history(history, num_epochs, num_batch, save_title):
    fig, ax = plt.subplots()
    ax.plot(range(len(history)), history, color="blue")
    ax.grid(linestyle="--")
    ax.set_xlabel("Iterations")
    ax.set_ylabel("BCE Loss")
    epoch_ticks = num_batch * np.arange(1, num_epochs + 1)
    ax.set_xticks(epoch_ticks)
    ax.set_xticklabels([f"Epoch {i + 1}" for i in range(len(epoch_ticks))])
    fig.savefig(os.path.join("figs", f"{save_title}_log.png"), dpi=300)
